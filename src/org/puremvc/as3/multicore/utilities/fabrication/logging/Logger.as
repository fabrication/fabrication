/** * Copyright (C) 2010 Rafał Szemraj. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.puremvc.as3.multicore.utilities.fabrication.logging {    import flash.utils.Dictionary;    import flash.utils.getQualifiedClassName;    import org.puremvc.as3.multicore.utilities.fabrication.logging.channel.ILogChannel;    /**     * Logger class is responsible for managing logged masseges from application. Each     * logger instance has name, log level and channel's repository. When logger is triggered     * for log message it's logged through all holded channels.     * @author Rafał Szemraj     */    public class Logger {        /**         * Name of logger         */        public var name:String;        /**         * logLevel of logger         */        public var logLevel:LogLevel;        /**         * Repository for log channels         * @see ILogChannel         */        private var _logChannels:Dictionary;        /**         * Constructor of Logger class         * @param name name of logger         * @param logLevel log level of logger. If null it's set to LogLevel.DEBUG. <strong>[ optional ]</strong>         * @see LogLevel         */        public function Logger(name:String, logLevel:LogLevel = null)        {            this.name = name;            this.logLevel = logLevel || LogLevel.DEBUG;        }        /**         * Logs given message at given log level, loggingObject is threaten as source of message         * @param message message to log         * @param messageLogLevel level at wich message will be logged         * @param loggingObject source of message. If omitted name of logger will be used <strong>[ optional ]</strong>         * @throws eu.szemraj.logging.channel.NoChannelPresentError if channel's repository is empty         */        public function log(message:*, messageLogLevel:LogLevel, loggingObject:* = null):void        {            if (!_logChannels) throw Error("No channel present in  [ " + name + " ] logger.");            if (logLevel.isGreaterOrEqual(messageLogLevel) && Log.getLogLevel().isGreaterOrEqual(messageLogLevel)) {                if (loggingObject) {                    loggingObject = loggingObject as String ? loggingObject : getQualifiedClassName(loggingObject);                }                else {                    loggingObject = name;                }                for each(var channel:ILogChannel in _logChannels) {                    channel.log(message, messageLogLevel, loggingObject);                }            }        }        public function timeStamp():void        {            var d:Date = new Date();            log("[ timeStamp ] " + d.toLocaleTimeString(), LogLevel.DEBUG);        }        /**         * Logs message with DEBUG log level         * @param message message to log         * @param loggingObject source of message. If omitted name of logger will be used <strong>[ optional ]</strong>         * @see LogLevel         */        public function debug(message:*, loggingObject:* = null):void        {            log(message, LogLevel.DEBUG, loggingObject);        }        /**         * Logs message with INFO log level         * @param message message to log         * @param loggingObject source of message. If omitted name of logger will be used <strong>[ optional ]</strong>         * @see LogLevel         */        public function info(message:*, loggingObject:* = null):void        {            log(message, LogLevel.INFO, loggingObject);        }        /**         * Logs message with WARN log level         * @param message message to log         * @param loggingObject source of message. If omitted name of logger will be used <strong>[ optional ]</strong>         * @see LogLevel         */        public function warn(message:*, loggingObject:* = null):void        {            log(message, LogLevel.WARN, loggingObject);        }        /**         * Logs message with ERROR log level         * @param message message to log         * @param loggingObject source of message. If omitted name of logger will be used <strong>[ optional ]</strong>         * @see LogLevel         */        public function error(message:*, loggingObject:* = null):void        {            log(message, LogLevel.ERROR, loggingObject);        }        /**         * Logs message with FATAL log level         * @param message message to log         * @param loggingObject source of message. If omitted name of logger will be used <strong>[ optional ]</strong>         * @see LogLevel         */        public function fatal(message:*, loggingObject:* = null):void        {            log(message, LogLevel.FATAL, loggingObject);        }        /**         * Inspects object ( eg. shows its structure in tree, datagrid etc ). How this method works         * depends on log channel inspectObject method implementation. <b>Important</b> - remember, it shows only dynamic         * properties of object. To show whole information use as3 flash.utils.describeType.         * @param object object to inspect         * @param objectName name of object. You can pass any string that distinguish current object from others,         * if omit "object" is set. <strong>[ optional ]</strong>         * @see ILogChannel         */        public function inspectObject(object:*, objectName:String = "object"):void        {            if (!_logChannels) throw new Error("No channel present in  [ " + name + " ] logger.");            if (logLevel.isGreaterOrEqual(LogLevel.NONE) && Log.getLogLevel().isGreaterOrEqual(LogLevel.NONE)) {                for each(var channel:ILogChannel in _logChannels) {                    try {                        channel.inspectObject(object, objectName);                    }                    catch(error:Error) {                        channel.log(error.toString(), LogLevel.ERROR, "Logger");                    }                }            }        }        /**         * Adds log channel to logger's channel repository         * @param logChannel instance of log channel         * @see ILogChannel         */        public function addChannel(logChannel:ILogChannel):void        {            if (!_logChannels) _logChannels = new Dictionary(false);            if ( !_logChannels[ logChannel ] )                 _logChannels[ logChannel ] = logChannel;        }    }}